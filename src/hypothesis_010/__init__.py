"""A Hypothesis extension for 010editor binary templates.

The only public API is `from_template`; check the docstring for details.
"""

import py010parser
import json
from bson import BSON
from hypothesis import strategies as st

__version__ = "0.0.1"
__all__ = ["from_template"]

def from_template(template_name: str) -> st.SearchStrategy[bytes]:
    """Parse the given template into a strategy."""
    
    ast = py010parser.parse_file(template_name) #Remove the IO from your library - Put it in a testing module or something
    #ast.show()
    byte_count = 0
    recursivehelper(ast, byte_count) #Visits the nodes, still yet to assign bytes to them.
    #Doing that will mean that when a file is generated, this module knows how each data structure is built and formatted (to my understanding)
         
    
    #assert ast is True, "we know we don't actually handle templates yet"
    return st.just(b"") 

def recursivehelper(node: py010parser.c_ast.Node, byte_count: int):
    if (len(node.children()) > 0):
        #TODO: Add a function here that takes a node name and adds the prerequisite bytes
        #Eg. a document in this spec has to have a size beforehand - will that
        for child_name, child in node.children():
            if (isinstance(child, list)):
                for elem in child:
                    recursivehelper(elem, byte_count)
            else:
                recursivehelper(child, byte_count)
    else:
        if (hasattr(node, 'name')):
            print("end node of:", node.name)
        elif (hasattr(node, 'names')):
            node_name = ""
            for item in node.names:
                node_name += item
            print("end node of:", node_name)
        elif (isinstance(node, py010parser.c_ast.Constant)):
            print("Constant here of type", node.type, "at value:", node.value)
        else:
            print(node, "is an end node of another type")
            

def value_from_template(ast: py010parser.c_ast.FileAST) -> st.SearchStrategy[any]:
    
    """Some kind of structure here - this is supposed to be applied to the ast given (from where again?)
    That means that it takes in the ast and returns a strategy that is supposed to successfully test each node and its children? I guess
    """
    
    """
    Lots of comments today but I BELIEVE at the moment that this function is just about applying hypothesis testing
    capabilities to each part of the AST in its given form. That means our recursive function only helps us identify the end nodes, not some of the trickier types that need multiple components.
    For BSON, that should be quickly identifiable - but it could be an issue in other file-type asts.
    """

    pass


def serialised_from_template(ast: py010parser.c_ast.FileAST) -> st.SearchStrategy[bytes]:
    return value_from_template(ast).map(partial(_dumps, ast))



def _dumps(ast: py010parser.c_ast.FileAST, value: object) -> bytes:
    
    #Let's try this only for BSON
    
    f = open("test.txt", "wb")
    binary_str = b""
    
    
    
    #Visit each node of the AST (already generated by py010parser)
    #Write the necessary bytes for each node - exploring each node as necessary.
    #eg a valid BSON document will have 4 bytes to begin with that are represented by the int32 at the start of the file, follwed by another element that ISN'T \x00 (in which case you go to the element node of the ast). Or, you follow it up with \x00.
    """The way I understand it is that you turn an object into a series of bytes here based on the corresponding type that it is in the AST? No way."""
    
    
    
    
    
    """Encode value according to the file format.
    
    Useful as s.map(partial(_dumps, ast))
    """