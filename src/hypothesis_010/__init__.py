"""A Hypothesis extension for 010editor binary templates.

The only public API is `from_template`; check the docstring for details.
"""

"""
Project Acknowledgements
Imported libraries were necessary for this project and are not my own work.
Everything else that isn't sourced from libraries in this code was my own work.
All of my work in this file was discussed with my supervisor Zac.
"""
import datetime

# Libraries for use in testing
import os
import struct
import sys
from functools import partial

import py010parser
from hypothesis import strategies as st

__version__ = "0.0.1"
__all__ = ["from_template"]


"""
ADDITIONAL POINTS TO CONSIDER FOR FURTHER WORK
Need to account for different machines - different architectures, compiler support etc.
For now, I've used global minimum and maximum values for the predefined types that exist in C - char, int etc, as they're common across all machines that would use this code
For safety's sake I've been hard-coded the appropriate values so far, but this could be revisited 
Also, Check the two's compliment thing - a bunch of the things have that specified
"""


"""
Here are some functions used to convert basic types into bytes.
These account for the different types in strategy_assignment_dict, of which there aren't many.
All other strategies generated by this file are canonicalised examples, so these can be applied to each element as long as the format options match those of the object generated by the strategy
"""

# Future works are worth checking whether all types of integers are properly encoded
# There may be some issues surrounding zero or other edge numbers like -128
def to_bytes_int(x: int, sign: bool) -> bytes:
    return x.to_bytes((x.bit_length() + 7) // 8, byteorder=sys.byteorder, signed=sign)


def to_bytes_char(x: chr) -> bytes:
    return bytes(x, "utf-8")


def to_bytes_float(x: float, float_format: str) -> bytes:
    return bytes(bytearray(struct.pack(float_format, x)))


"""
Global assignment dictionary for primitive types used, and the function or functions you would use to write their generated examples into bytestrings
"""
strategy_assignment_dict = {
    "int": (
        st.integers(min_value=-2147483648, max_value=2147483647),
        partial(to_bytes_int, sign=True),
    ),
    "unsignedint": (
        st.integers(min_value=0, max_value=4294967295),
        partial(to_bytes_int, sign=False),
    ),
    "uint": (
        st.integers(min_value=0, max_value=4294967295),
        partial(to_bytes_int, sign=False),
    ),
    "int16": (
        st.integers(min_value=-32768, max_value=32767),
        partial(to_bytes_int, sign=True),
    ),
    "uint16": (
        st.integers(min_value=0, max_value=65535),
        partial(to_bytes_int, sign=False),
    ),
    "unsignedint16": (
        st.integers(min_value=0, max_value=65535),
        partial(to_bytes_int, sign=False),
    ),
    "int64": (
        st.integers(min_value=-9223372036854775808, max_value=9223372036854775807),
        partial(to_bytes_int, sign=True),
    ),
    "uint64": (
        st.integers(min_value=0, max_value=18446744073709551615),
        partial(to_bytes_int, sign=False),
    ),
    "unsignedint64": (
        st.integers(min_value=0, max_value=18446744073709551615),
        partial(to_bytes_int, sign=False),
    ),
    "short": (
        st.integers(min_value=-32768, max_value=32767),
        partial(to_bytes_int, sign=True),
    ),
    "unsignedshort": (
        st.integers(min_value=0, max_value=65535),
        partial(to_bytes_int, sign=False),
    ),
    "ushort": (
        st.integers(min_value=0, max_value=65535),
        partial(to_bytes_int, sign=False),
    ),
    "word": (
        st.integers(min_value=0, max_value=65535),
        partial(to_bytes_int, sign=False),
    ),
    "dword": (
        st.integers(min_value=-2147483648, max_value=2147483647),
        partial(to_bytes_int, sign=True),
    ),
    "long": (
        st.integers(min_value=-9223372036854775808, max_value=9223372036854775808),
        partial(to_bytes_int, sign=True),
    ),
    "longlong": (
        st.integers(min_value=-9223372036854775808, max_value=9223372036854775808),
        partial(to_bytes_int, sign=True),
    ),
    "unsignedlong": (
        st.integers(min_value=0, max_value=18446744073709551615),
        partial(to_bytes_int, sign=False),
    ),
    "ulong": (
        st.integers(min_value=0, max_value=18446744073709551615),
        partial(to_bytes_int, sign=False),
    ),
    "float": (st.floats(width=32), partial(to_bytes_float, float_format="!f")),
    "double": (st.floats(width=64), partial(to_bytes_float, float_format="!d")),
    "hfloat": (st.floats(width=16), partial(to_bytes_float, float_format="!e")),
    "byte": (st.characters(min_codepoint=0, max_codepoint=255), to_bytes_char),
    "ubyte": (st.characters(min_codepoint=0, max_codepoint=255), to_bytes_char),
    "char": (st.characters(min_codepoint=0, max_codepoint=255), to_bytes_char),
    "unsignedchar": (
        st.characters(min_codepoint=0, max_codepoint=255),
        to_bytes_char,
    ),  # There could be chars that are below 0?
    "uchar": (st.characters(min_codepoint=0, max_codepoint=255), to_bytes_char),
    "second": (
        st.integers(min_value=0, max_value=31),
        partial(to_bytes_int, sign=False),
    ),  # dostime strats
    "minute": (
        st.integers(min_value=0, max_value=63),
        partial(to_bytes_int, sign=False),
    ),
    "hour": (st.integers(min_value=0, max_value=31), partial(to_bytes_int, sign=False)),
    "tagdostime": (
        st.tuples(
            st.integers(min_value=0, max_value=31),
            st.integers(min_value=0, max_value=63),
            st.integers(min_value=0, max_value=31),
        ),
        lambda t: b"".join(map(partial(to_bytes_int, sign=False), t)),
    ),
    "day": (st.integers(min_value=0, max_value=31), partial(to_bytes_int, sign=False)),
    "month": (
        st.integers(min_value=0, max_value=15),
        partial(to_bytes_int, sign=False),
    ),
    "year": (
        st.integers(min_value=0, max_value=127),
        partial(to_bytes_int, sign=False),
    ),
    "tagdosdate": (
        st.tuples(
            st.integers(min_value=0, max_value=31),
            st.integers(min_value=0, max_value=15),
            st.integers(min_value=0, max_value=127),
        ),
        lambda t: b"".join(map(partial(to_bytes_int, sign=False), t)),
    ),
    "dwlowdatetime": (
        st.integers(min_value=-2147483648, max_value=2147483647),
        partial(to_bytes_int, sign=True),
    ),
    "dwhighdatetime": (
        st.integers(min_value=-2147483648, max_value=2147483647),
        partial(to_bytes_int, sign=True),
    ),
    "_filetime": (
        st.tuples(
            st.integers(min_value=-2147483648, max_value=2147483647),
            st.integers(min_value=-2147483648, max_value=2147483647),
        ),
        lambda t: b"".join(map(partial(to_bytes_int, sign=True), t)),
    ),
}

# Left alone for actual use, but it's useful for debugging
unassigned_strats = (
    []
)  # For listing off objects that don't have a strategy in either the dictionary above or a way to compose them in parseTree below

"""
Global variables for where the strategies to be used in the filetype parsed are written,
And blank context is used as a starter string for contexts to be written to during parseTree
"""
strat_dict = {}
blank_context = ""

# Set this to true to ensure the file strategy generates bytes instead of objects - chars, ints etc
# (By basically mapping the appropriate to_bytes functions across the elements)
# If it's false hypothesis returns the strategy without transforming it into bytes
gen_as_bytes = True

# Assign strategy to end nodes according to whether desired outcome is raw object or bytes
def strat_assign(node_name: str, gen_as_bytes: bool) -> st.SearchStrategy[any]:
    nodename = node_name.lower()
    nodename = nodename.lstrip()
    nodename = nodename.rstrip()
    if nodename in strategy_assignment_dict:
        strat, function = strategy_assignment_dict[nodename]
        if gen_as_bytes:
            return strat.map(function)
        return strat
    else:
        print(node_name + " needs assigning?")
        unassigned_strats.append(node_name)
        return st.none()


# Generate a hypothesis strategy from the filepath to the binary template provided (as a string),
# Then turns an example of it into bytes if gen_bytes is set to true
# Otherwise produces an example of the composite strategy formed, and returns an empty bytestring
# In either case, the composite strategy will be formed and stored in the global dictionary above (if it generates properly)
def from_template(template_name: str, gen_bytes: bool) -> st.SearchStrategy[bytes]:
    """Parse the given template into a strategy."""

    ast = py010parser.parse_file(template_name)

    global gen_as_bytes  # Used by other functions, can be set to true to draw a bytestring example
    gen_as_bytes = gen_bytes
    ast_strat = parseTree(ast, blank_context)

    # ast_strat now contains the file's strategy that can be used to generate valid examples
    if gen_as_bytes:
        print("File strategy turned into bytes")
        file_example = ast_strat.example()
        file_example = to_bytes_recursive(file_example)
        return file_example
    else:
        print("File strategy not turned into bytes.")
        file_example = ast_strat.example()
        return st.just(b"")

    # Just in case something goes wonky
    return st.just(b"")


def getNodeName(node: py010parser.c_ast.Node) -> str:
    if hasattr(node, "name"):
        node_name = node.name
        return node_name
    else:
        node_name = node.__class__.__name__
        return node_name


def createContextName(parentcontext: str, node: py010parser.c_ast.Node) -> str:
    return parentcontext + getNodeName(node)


def parseTree(node: py010parser.c_ast.Node, context: str) -> st.SearchStrategy[any]:
    # Create current context - path to reach this node
    mycontext = createContextName(context, node)

    if len(node.children()) > 0:

        if isinstance(node, py010parser.c_ast.FileAST):
            for child_name, child in node.children():
                parseTree(child, mycontext)
            # This is currently very specific for Mifare4k this time only, I'm out of time
            # This "file" appended to my_context is just the name for the file's root node
            # Each file spec has their own root node however (aside from the global ones that are present in every ast)
            # This is the first place to come back to for further work and something I plan on doing on my own
            if (mycontext + "file") in strat_dict:
                print("AST Strat assigned, can be found in strat_dict using the key", mycontext)
                strat_dict[mycontext] = strat_dict[(mycontext + "file")]
                # This with statement below writes the output strategy into a text file for your perusal
                # with open("Result_Strat.txt", "w") as result_file:
                #    print(strat_dict[mycontext], file=result_file)
                # You could definitely create a database of files like this, but I just used this for debugging purposes
                return strat_dict[mycontext]
            else:
                print(
                    "No valid root node found, check through the produced strat_dict and find the corresponding root to look for in the function"
                )
                return st.none()

        # ArrayDecls in this ast always include a type of object in that array and a dimension attribute
        elif isinstance(node, py010parser.c_ast.ArrayDecl):
            array_length = int(node.dim.value)
            parseTree(node.type, mycontext)
            array_contents = getNodeName(node.type)
            strat_dict[mycontext] = st.lists(
                elements=strat_dict[(mycontext + array_contents)],
                min_size=array_length,
                max_size=array_length,
            ).map(tuple)

        elif isinstance(node, py010parser.c_ast.Struct):
            if node.name.lower() in strategy_assignment_dict:
                # Useful to know when the struct you've accessed should be common across all template files, and thus found in strategy_assignment_dict
                # print("It's a global dtype, should be in the strategy_assignment_dict")
                strat_dict[mycontext] = strat_assign(node.name.lower(), gen_as_bytes)
            else:
                struct_strat_list = []
                for child_name, child in node.children():
                    parseTree(child, mycontext)
                    recorded_child_name = getNodeName(child)
                    struct_strat_list.append(
                        strat_dict[(mycontext + recorded_child_name)]
                    )
                    strat_dict[mycontext] = st.tuples(*struct_strat_list)

        # Decls mishandles a lot of things - Mainly, any decls that have more than one child.
        # This is because in most examples I've looked at it will rely on types and/or values evaluated in some other part of the tree
        # For the most part however this is fixable, given further effort on the tool
        elif isinstance(node, py010parser.c_ast.Decl):
            if len(node.children()) == 1:
                parseTree(node.children()[0][1], mycontext)
                node_name = getNodeName(node.children()[0][1])
                strat_dict[mycontext] = strat_dict[(mycontext + node_name)]
            else:
                print(
                    "This decl of: "
                    + node.name
                    + " is one of those cases with two children, a type and a dimension."
                )
                print("Leaving this decl alone, it hasn't been handled yet")

        elif isinstance(node, py010parser.c_ast.TypeDecl):
            # Assumes a lot of things - typedecls are usually only made with one child, an identifiertype, that usually exists in the global dictionary already.
            # Probably worth looking through the strategy dictionary for things that match that of the identifiertype, if you can't find it in strategy_assignment_dict
            if len(node.children()) == 1 and isinstance(
                node.children()[0][1], py010parser.c_ast.IdentifierType
            ):
                parseTree(node.children()[0][1], mycontext)
                node_name = ""
                for item in node.children()[0][1].names:
                    node_name += item
                strat_dict[mycontext] = strat_dict[
                    (mycontext + node.children()[0][1].__class__.__name__ + node_name)
                ]

            elif len(node.children()) == 1 and isinstance(
                node.children()[0][1], py010parser.c_ast.Struct
            ):
                parseTree(node.children()[0][1], mycontext)
                strat_dict[mycontext] = strat_dict[
                    (mycontext + node.children()[0][1].name)
                ]
            else:
                for child_name, child in node.children():
                    parseTree(child, mycontext)
                    if hasattr(child, "name"):
                        print("Accessed: " + child.name)
                        strat_dict[mycontext] = strat_dict[(mycontext + child.name)]
                    else:
                        print("Accessed: " + child.__class__.__name__)
                        strat_dict[mycontext] = strat_dict[
                            (mycontext + child.__class__.__name__)
                        ]

        # General case
        else:
            for child_name, child in node.children():
                # Below will be useful in looking at further work
                # print("Accessing: " + getNodeName(child))
                parseTree(child, mycontext)

    # End nodes only, should assign base strategies for these end nodes
    else:
        if isinstance(node, py010parser.c_ast.IdentifierType):
            if hasattr(node, "name"):
                mycontext += node.name
                my_strategy = strat_assign(node.name, gen_as_bytes)
            elif hasattr(node, "names"):
                node_name = ""
                for item in node.names:
                    node_name += item
                mycontext += node_name
                my_strategy = strat_assign(node_name, gen_as_bytes)
            strat_dict[mycontext] = my_strategy
        else:
            print(
                "This isn't an identifier type, which means it's some other value probably important to the parent. Exiting without doing anything"
            )


# To generate examples of the produced file strategy
# Only used during bytestring generation when gen_as_bytes is set to True!
def example_to_bytes(strat: st.SearchStrategy[any]) -> bytes:
    strat_example = strat.example()
    strat_example = to_bytes_recursive(strat_example)
    return strat_example


# Defined this way as list or tuple strategies are handled during generation to output tuples
# Only used during bytestring generation
def to_bytes_recursive(strat: tuple):
    concatenated_example = b""
    for elem in strat:
        if isinstance(elem, bytes):
            concatenated_example += elem
        else:
            concatenated_example += to_bytes_recursive(elem)
    return concatenated_example


# Performance tests of this artefact on its own
# Pass a number of unique examples that you want to generate for your test,
# This script will tell you how long it took to generate them and some other useful performance metrics
def testing_script(number_of_unique_examples: int):
    blank_context = ""
    example_collection = set()
    times = []
    
    time_start = datetime.datetime.now()
    ast = py010parser.parse_file(os.path.join(os.getcwd(), "templateRepo/Mifare4k.bt"))
    ast_strategy = parseTree(ast, blank_context)
    strat_gen = datetime.datetime.now()
    time_strat_gen = strat_gen - time_start
    
    time_start_examples = datetime.datetime.now()
    times.append(time_start_examples)
    while len(example_collection) < number_of_unique_examples:
        new_example = example_to_bytes(ast_strategy)
        example_collection.add(new_example)
        iteration_time = datetime.datetime.now()
        previous_iter = times[-1]
        this_iteration = iteration_time - previous_iter
        times.append(this_iteration)
        
    time_finish = datetime.datetime.now()
    time_total = time_finish - time_start
    avg_example_timestamp = time_finish - time_start_examples
    avg_example_time = avg_example_timestamp.total_seconds() / float(len(times))
    print(
        f"Finished testing, took {time_total.total_seconds():.3f} seconds to create the strategy and generate 100 unique examples"
    )
    print(
        f"Time to create strategy from binary template file: {time_strat_gen.total_seconds():.3f} seconds"
    )
    print(
        f"Average time to generate an example from the strategy: {avg_example_time:.3f} seconds"
    )
    print(
        f"Produced {len(times)} examples, of which {len(example_collection)} were unique"
    )

if __name__ == '__main__':
    if (len(sys.argv) == 3):
        template_name = sys.argv[1]
        print("Template name: ", template_name)
        gen_bytes = sys.argv[2]
        print("Generate as bytes? ", gen_bytes)
        from_template(template_name, gen_bytes)


"""
There were numerous old functions below here that I have since deleted for my final submission
They'll be in the previous commit of this repository, if they're needed
All that I used from them were structuring ideas really, or the ideas gained from experimenting with them
"""
